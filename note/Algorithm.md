# 算法

## 散列表

### 拉链法

​		将大小为M的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。
​		查询时首先根据散列值找到对应的链表，然后沿着链表顺序查找对应的键。

### 线性探测法

​		用大小为M的数组保存N个键值对，M > N，依赖数组中的空位解决碰撞冲突，基于这种策略的所有方法被统称为开放地址散列表。线性探测法是开放地址散列表中最简单的方法。
​		当发生碰撞时，直接检查散列表中的下一个位置，索引+1。核心思想就是将用于链表的内存用作散列表中的空元素，空元素可以作为查询结束的标志。

## 无向图

### 连通图

​		如果图中任意两点都是连通的，那么该图称为连通图。

### 连通分量

​		无向图G的极大连通子图称为G的连通分量( Connected Component)。任何连通图的连通分量只有一个，即是其自身，非连通的无向图有多个连通分量。

​		如果无向图连通，那么极大连通子图为它本身（也称为连通分量），极小连通子图为生成树；如果无向图不连通，可能存在多个极大连通子图和多个极小连通子图。

### 边双连通分量

​		对于无向图G，去掉任意一条边都不会改变图G的连通性，即该图不存在桥，则称为边双连通图。

​		一个无向图的极大边双连通子图称为此无向图的边双连通分量。连接两个边双连通分量的边即是桥。

### 点双连通分量

​		对于无向图G，去掉任意一个顶点都不会改变图G的连通性，即该图没有割点，则称为点双连通图。

​		一个无向图的极大点双连通子图称为此无向图的点双连通分量。

​		点双连通分量一定是边双连通分量。

### 割点

​		对于一个无向图，如果删除顶点v及其连接的所有边后，该图的连通分量数量增加，则称该点v为该图的割点。

### 桥

​		对于图G，如果删除边(u,v)会导致该图的连通分量数量增加，则边(u,v)为该图的桥。

### Tarjan 算法求解无向图的割点与桥

#### 		时间戳

​		用来标记图中每个节点在进行深度优先搜索时被访问的时间顺序，即一个递增的序号，用dfn[x]来表示。

#### 		追溯值

​		用来标记当前顶点沿搜索树继续前进能到达的最小时间戳，用low[x]表示。在求割点的算法中，如果顶点w不经过父顶点v还能到达更小时间戳的顶点，也就是祖先顶点，那说明移除顶点v不会影响图的连通性，反之则说明顶点v为割点。

```java
import java.util.Deque;
import java.util.LinkedList;

public class TarjanCutVertex {

    private Deque<Integer> cutVertexList = new LinkedList<>();

    public TarjanCutVertex(Graph graph) {
        int[] dfn = new int[graph.vertex()];
        int[] low = new int[graph.vertex()];
        for (int v = 0; v < graph.vertex(); v++) {
            if (dfn[v] == 0) {
                this.dfs(graph, v, v, v, dfn, low, 0);
            }
        }
    }

    /**
     * @param graph  当前无向图
     * @param v      当前搜索顶点ID
     * @param parent 当前顶点v的父顶点
     * @param root   当前搜索树的根顶点
     * @param dfn    顶点对应时间戳
     * @param low    顶点可达顶点中的最小时间戳
     * @param index  本次搜索的时间戳
     */
    private void dfs(Graph graph, int v, int parent, int root, int[] dfn, int[] low, int index) {
        //当前顶点下"参与搜索"的子节点数量
        int c = 0;
        //dfn[v]=0则表示当前顶点还没有被访问过
        dfn[v] = low[v] = ++index;
        for (int w : graph.adjacency(v)) {
            if (dfn[w] == 0) {
                c++;
                //如果w还未被访问过，继续向下进行搜索
                this.dfs(graph, w, v, root, dfn, low, index);
                //v可达最小顶点的时间戳为v和w中的较小者
                low[v] = Math.min(low[v], low[w]);
                if (root == v && c >= 2) {
                    //如果顶点v是根顶点且当前搜索子节点大于等于2，则v必为割点
                    this.cutVertexList.push(v);
                } else if (root != v && low[w] >= dfn[v]) {
                    //如果不经过顶点v，顶点w再也无法到达v的父顶点，那么顶点v是割点
                    this.cutVertexList.push(v);
                }
            } else if (parent != w) {
                //如果w不是v的父顶点，并且w已经被访问过了，说明w是v的祖先顶点
                low[v] = Math.min(low[v], dfn[w]);
            }
        }
    }

    public Iterable<Integer> cutVertex() {
        return this.cutVertexList;
    }

}
```

### 欧拉图

​		一个图能遍历完所有的边而没有重复遍历的边，这样的图称为欧拉图，遍历时的路径称为欧拉路径（欧拉通路），如果该路径闭合，那么也称为欧拉回路。

#### 欧拉通路存在条件

无向图：图连通，两个顶点是奇度数，其余顶点是偶度数。

有向图：图强连通，一个顶点出度=入度+1，一个顶点入度=出度+1，剩余顶点出度=入度。

#### 欧拉回路存在条件

无向图：图连通，所有顶点都是偶数度。

有向图：图强连通，所有顶点出度=入度。

## 有向图

### 强连通

​		如果两个顶点V和W是互相可达的，则称它们为强连通的。如果一幅图中任意两点都是强连通的，那么这幅有向图是强连通的。

### 强连通分量

​		有向图的极大强连通子图称为强连通分量。

### 传递闭包

​		有向图的领接矩阵表示两个顶点之间是否存在边，而传递闭包则表示两个顶点之间能否到达，顶点A和B之间可能没有边直接相连，但是A可以通过其它顶点间接到达B，那么在传递闭包的矩阵中，第A行第B列为true。

### 实际应用

​		1.有向图的多点可达性分析可用于java垃圾回收算法中的标记-清除算法。

​		2.有向图的有向环分析和顶点排序结合可以实现任务调度的检查和拓扑排序，保证任务完成的先后顺序。

## 技巧

### 对于指定数值，返回2的最小整数幂

```java
    /**
     * 对于给定数值，返回2的最小整数幂
     * 例如：
     * 13 -> 16
     * 16 -> 16
     */
    private static final int MAXIMUM_CAPACITY = 1 << 30;
    private static int fun(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
```

## 常见概念

### 在线算法和离线算法

​		在线算法是可以按照串行的方式逐个处理输入的算法，而离线算法需要在问题一开始就提供整个问题的数据。

​		例如：选择排序是离线算法，而插入排序是在线算法。因为选择排序需要访问整个输入，选择最值，而插入排序每次迭代都只考虑一个输入元素，产生部分解决方案，不考虑后续输入元素。

