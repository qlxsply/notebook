## 悲观锁 乐观锁
```
悲观锁和乐观锁是锁的一种宏观分类方式，在并发情况下的两种不同策略。悲观锁阻塞事务，乐观锁回滚重试。
```
## synchronized
```
锁升级：偏向锁 → 轻量级锁 → 重量级锁
1.偏向锁
当线程A第一次到达synchronized代码块的时候，锁对象变成偏向锁（通过CAS修改对象头里的锁标志位），代表偏向于第一个获得它的线程。
需要注意的是，执行完同步代码块之后，线程并不会主动释放偏向锁。
当线程A第二次到达synchronized代码块的时候，线程将判断持有锁的线程是否就是自己（持有锁的线程ID就在synchronized锁住的对象头里面），如果是则正常执行。
由于线程没有释放锁，所以如果自始至终只有一个线程使用锁的话，偏向锁几乎没有额外消耗，性能最高。
2.轻量级锁（自旋锁）
当出现锁竞争的时候，偏向锁就会升级为轻量级锁（自旋锁）。
自旋锁不停地循环进行CAS操作，就是先判断当前锁的标志位是否为“释放”，如果是就设置为“锁定”，并将当前锁的持有者修改为自己。
自旋期间的线程只能原地空耗CPU，自旋锁通过这种方式换取线程在用户态和内核态之间切换的开销。
3.重量级锁
很明显不可能让自旋锁无限的忙等（自旋空耗CPU），会有一个计数器记录自旋的次数，默认允许自旋10次，可通过虚拟机参数修改。如果有某个线程达到了最大自旋次数，会通过CAS修改锁的标志位为重量级锁，但是不修改锁的持有者。
这样，当有后续线程尝试获取锁的时候，发现是重量级锁，就直接挂起而不是忙等，等待被唤醒。
```
- 注意：多个线程轮流获取锁，如果每次都是正常获取，没有发生阻塞，就不存在锁竞争。只有当某个线程试图获取锁时，发现该锁已经被占用，需要等待其释放，才会发生锁竞争。
- 注意：一个锁只能按照 偏向锁、轻量级锁、重量级锁的顺序逐渐升级（也有叫锁膨胀的），不允许降级。
- 问题：偏向锁时，A线程执行完后不释放锁，B线程尝试获取锁时，发现是偏向锁，就会判断线程A是否仍然存活，如果A存活，就会暂停A线程并将锁升级为轻量级锁，然后A继续执行，B自旋。如果A不存在则B直接持有该偏向锁，锁不升级。
## 可重入锁
```
允许同一个线程多次获取同一把锁

```
## 公平锁 非公平锁
```
如果多个线程申请一把公平锁，那么当锁释放的时候，先申请的先得到，非常公平。显然如果是非公平锁，后申请的线程可能先获取到锁，是随机或者按照其他优先级排序的。
ReentrantLock通过构造函数传参可以指定该锁是否是公平锁，默认是非公平锁.
synchronized是一种非公平锁，无法变成公平锁。
```
## 可中断锁
```
可以响应中断的锁。
Java并没有提供任何直接中断某线程的方法，只提供了中断机制。何谓“中断机制”？线程A向线程B发出“请你停止运行”的请求（线程B也可以自己给自己发送此请求），但线程B并不会立刻停止运行，而是自行选择合适的时机以自己的方式响应中断，也可以直接忽略此中断。也就是说，Java的中断不能直接终止线程，而是需要被中断的线程自己决定怎么处理。
例如：线程A持有锁，线程B等待获取该锁。由于线程A持有锁的时间过长，线程B不想继续等待了，我们可以让线程B中断自己或者在别的线程里中断它，这种就是可中断锁。
synchronized就是不可中断锁，而Lock的实现类都是可中断锁。
```
## 读写锁、共享锁、互斥锁
```
读写锁其实是一对锁，一个读锁（共享锁）和一个写锁（互斥锁、排他锁）。
写锁:别的线程无论读还是写都需要等待
读锁:其他线程如果也要加读锁，不需要等待，可以直接获取（读锁计数器+1）
```
- 注意：读写锁是悲观锁策略。因为读写锁并没有在更新前判断值有没有被修改过，而是在加锁前决定应该用读锁还是写锁。乐观锁特指无锁编程,不是锁，而是一个在循环里尝试CAS的算法。
- 我认为判断一个锁是乐观锁还是悲观锁时，应该看它是如何锁住数据的。如果线程A已经获取到了某一份数据的读写权限，那么线程B依然能对该数据进行读写，只有在进行更新操作时，AB线程才去判断自己能否更新，那么这就是乐观锁。而读锁和轻量级锁之类的，在他们获取数据之前，就已经确定自己不能更新数据或者别的线程不能获取数据，这就是悲观锁。至于轻量级锁中的CAS，只是在获取锁自身的标志位时使用的是乐观锁思想，即轻量级锁这个悲观锁内部是通过乐观锁实现的。